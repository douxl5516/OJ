/*
    |Dijkstra算法|
    |适用于边权为正的有向图或者无向图|
    |求从单个源点出发，到所有节点的最短路|
    |优化版：时间复杂度 O(elbn)|
    |16/11/05ztx, thanks to chaixiaojun|
*/

struct node {
    int v, len;
    node(int v = 0, int len = 0) :v(v), len(len) {}
    bool operator < (const node &a)const {  //  距离从小到大排序
        return len > a.len;
    }
};

vector<node>G[maxn];
bool vis[maxn];
int dis[maxn];

void init() {
    for (int i = 0; i<maxn; i++) {
        G[i].clear();
        vis[i] = false;
        dis[i] = INF;
    }
}
int dijkstra(int s, int e) {
    priority_queue<node>Q;
    Q.push(node(s, 0)); //  加入队列并排序
    dis[s] = 0;
    while (!Q.empty()) {
        node now = Q.top();     //  取出当前最小的
        Q.pop();
        int v = now.v;
        if (vis[v]) continue;   //  如果标记过了, 直接continue
        vis[v] = true;
        for (int i = 0; i<G[v].size(); i++) {   //  更新
            int v2 = G[v][i].v;
            int len = G[v][i].len;
            if (!vis[v2] && dis[v2] > dis[v] + len) {
                dis[v2] = dis[v] + len;
                Q.push(node(v2, dis[v2]));
            }
        }
    }
    return dis[e];
}
