/*
    |Prim算法|
    |适用于 稠密图 求最小生成树|
    |堆优化版，时间复杂度：O(elgn)|
    |16/11/05ztx, thanks to chaixiaojun|
*/

struct node {
    int v, len;
    node(int v = 0, int len = 0) :v(v), len(len) {}
    bool operator < (const node &a)const {  // 加入队列的元素自动按距离从小到大排序
        return len> a.len;
    }
};

vector<node> G[maxn];
int vis[maxn];
int dis[maxn];

void init() {
    for (int i = 0; i<maxn; i++) {
        G[i].clear();
        dis[i] = INF;
        vis[i] = false;
    }
}
int Prim(int s) {
    priority_queue<node>Q; // 定义优先队列
    int ans = 0;
    Q.push(node(s,0));  // 起点加入队列
    while (!Q.empty()) {
        node now = Q.top(); Q.pop();  // 取出距离最小的点
        int v = now.v;
        if (vis[v]) continue;  // 同一个节点，可能会推入2次或2次以上队列，这样第一个被标记后，剩下的需要直接跳过。
        vis[v] = true;  // 标记一下
        ans += now.len;
        for (int i = 0; i<G[v].size(); i++) {  // 开始更新
            int v2 = G[v][i].v;
            int len = G[v][i].len;
            if (!vis[v2] && dis[v2] > len) {
                dis[v2] = len;
                Q.push(node(v2, dis[v2]));  // 更新的点加入队列并排序
            }
        }
    }
    return ans;
}
